## 写在前面

> Android Studio 2.2+已支持CMake编译，与以前NDK-Build方式相比方便了不少，本文旨在引导大家在AS2.2+下一步一步建立JNI工程进行开发，并假设大家已经对JNI相关知识有所了解，不作代码解释，文末附代码GitHub地址。

AS更新之前进行JNI开发需要配置指定的Gradle版本（还是实验版本），[参见链接](http://tools.android.com/tech-docs/new-build-system/gradle-experimental)，相对应的HelloWorld工程已上传，[下载地址](https://github.com/hayukleung/appjni)，本文抛开NDK-Build，使用最新的CMake工具链新建工程，大家各取所需。

---
开始分割线，严肃脸

---

## 建立工程

![新建工程，勾选Include C++ Support](http://upload-images.jianshu.io/upload_images/2048485-f265dd9a948fba95.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![选择Toolchain Default](http://upload-images.jianshu.io/upload_images/2048485-eebadeba630d04d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Android视图](http://upload-images.jianshu.io/upload_images/2048485-67b25cd3a6daf0a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![Project视图](http://upload-images.jianshu.io/upload_images/2048485-73836884cb696cec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

0）HelloWorld

编写JNIInterface.java
```java
public class JNIInterface {
  static {
    // 库名下文提及
    System.loadLibrary("com_hayukleung_jni_JNIInterface");
  }
  public native String stringFromJNI();
}
```

为方便快速编写JNIInterface对应的C头文件，我写了一个shell脚本，放置于工程根目录，**修改里面的路径常量后**，运行即可生成。

```shell
./jni_header_generator.sh com/hayukleung/jni/JNIInterface.java com.hayukleung.jni.JNIInterface
```

得到的C头文件
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_hayukleung_jni_JNIInterface */
#ifndef _Included_com_hayukleung_jni_JNIInterface
#define _Included_com_hayukleung_jni_JNIInterface
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_hayukleung_jni_JNIInterface
 * Method:    stringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_com_hayukleung_jni_JNIInterface_stringFromJNI
        (JNIEnv *, jobject);
#ifdef __cplusplus
}
#endif
#endif
```
拷贝该头文件，后缀改为.c或.cpp，实现函数`Java_com_hayukleung_jni_JNIInterface_stringFromJNI`
```c
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "com_hayukleung_jni_JNIInterface.h"
/* Header for class com_hayukleung_jni_JNIInterface */
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     com_hayukleung_jni_JNIInterface
 * Method:    stringFromJNI
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL
Java_com_hayukleung_jni_JNIInterface_stringFromJNI(JNIEnv *env, jobject obj) {
    return (*env)->NewStringUTF(env, "JNIInterface-->HelloWorld");
}
#ifdef __cplusplus
}
#endif
```

打开CMakeLists.txt，将com_hayukleung_jni_JNIInterface.c文件路径添加进去，生成的库名建议与该文件一致，不至于与其它库混淆
```txt
add_library( com_hayukleung_jni_JNIInterface // 生成的库的库名
             SHARED
             src/main/cpp/com_hayukleung_jni_JNIInterface.c ) // 路径
```

写个Activity展示这个字符串
```java
public class CallbackActivity extends AppCompatActivity {

  @Override protected void onCreate(@Nullable Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    TextView text = new TextView(this);
    text.setText(new JNIInterface().stringFromJNI());
    setContentView(text);
  }
}
```

编译，运行，结束。

1）JAVA调用C/C++函数
> 这里我们以一个斐波那契数列的计算为例子，使用C/C++编写函数计算数列，JAVA端调用并显示结果

不贴代码了，文末附GitHub地址

2）C/C++调用JAVA方法

不贴代码了，这里写了三个JAVA方法供C调用，函数签名如下
```java
// 函数签名：()V
void func();
// 函数签名：(I)V
void func(int);
// 函数签名：(Ljava/lang/String;)V
void func(String);
```

附录

| Java类型 |对应的签名            | 例子 |
|:-------- | :------------------ | :-- |
| boolean | Z ||
| byte	  | B ||
| char	  | C ||
| short   | S ||
| int	    | I ||
| long	  | L ||
| float   | F ||
| double  | D ||
| void    | V ||
| Object	| L用/分割包的完整类名; | Ljava/lang/String; |
| Array	  | [签名                | [I or [Ljava/lang/String; |

[GitHub源码](https://github.com/hayukleung/JNI)